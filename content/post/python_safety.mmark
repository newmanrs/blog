---
title: "Python Safety"
date: 2018-03-07T16:39:32-08:00
draft: False
---

Warning: Post requires at least knowledge of programming with python.

Every now and then I feel the urge to try to make my python scripts more gracefully validate inputs without descending into an entirely unfortunate snarl. Here's one such approach.

<!--more-->

So it came to pass I wanted to at least assert when parsing large amounts of irregular data from irregular sources^[I work at a hospital.  There is no data curation.].  And in general I do somewhat loathe software that runs on nothing but dictionaries where you can't easily understand the control flow by reading it.  Perhaps this is not pythonic, but I came up with this easy to use boiler plate for validating dictionary keys that also gives me some form of type safetly.

And I also like code that ties my hands, and other user's hands as much as possible.  So here we are introducing my container class, which is pulling from collections.MutableMapping which forces me to implement enough abstract methods.  Setting the `metaclass = abc.ABCMeta` allows me to define more abstact methods that must be overwritten.  This is some classic object oriented programming that I rarely have seen in python scripts built by academics.

```python
class Container(collections.MutableMapping, metaclass = abc.ABCMeta):
    def __init__(self,*args, **kwargs):

        if not self._required_kwargs() <= kwargs.keys():
            msg = "Received kwargs {}, require kwargs {}".format(kwargs.keys(), self._required_kwargs())
            raise AttributeError(msg)
        self.__dict__.update(*args, **kwargs)

    def __iter__(self):
        return iter(self.__dict__)

    def __len__(self):
        return len(self.__dict__)

    def __str__(self):
        return str(self.__dict__)

    def __setitem__(self, key, value):
        self.__dict__[key] = value

    def __getitem__(self, key):
        return self.__dict__[key]

    def __delitem__(self, key):
        del self.__dict__[key]

    @abc.abstractmethod
    def _required_kwargs(self):
        """ Replace this prototype """
        required_kwargs = set([])
        return required_kwargs
```

We have to make concrete classes of course, to use this.  But these are fast.

```python
class StateSpace(Container):

    def _required_kwargs(self):
        return set(['state_space_name','ordered_values','unordered_values'])
```

To use these we can just build and feed in dictionaries:

```python
    d = dict()
    d['state_space_name'] = 'whatever'
    d['ordered_values'] = [1,2,3]
    d['unordered_values'] = ['a','b']
    d['cruft'] = 'someextrastuff'

    s = StateSpace(**d)
```

and the resulting class will behave like an ordinary dictionary.  Classes that derive from `Container` must provide an implementation of `_required_kwargs` to avoid an exception, and dictionaries without the required keys also throw an exception.  I've chosen to tolerate extra keys.

I've found this to give myself a reasonable bit of safety, for not too much effort.  I think having named dictionary types also gives the code at least some semantics and gives much better clues to the reader.  A minor extension of this could also be to used to try to enforce type safety as well, but that is a rabbit hole I don't want to get into.

I think this pattern though strikes a reasonable balance between boilerplate waste, user time, and safety.
